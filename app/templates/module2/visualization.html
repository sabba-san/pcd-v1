<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualization - Lidar Defect Viewer </title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; margin:0; padding:0; background:#f3f4f6; color:#1e293b; overflow: hidden; height: 100vh; }
        .card { width: 100%; height: 100vh; margin:0; padding:0; background:#fff; border-radius:0; box-shadow:none; display: flex; flex-direction: column; }
        
        /* Light Mode */
        body.light-mode { background: #f8fafc; color: #1e293b; }
        body.light-mode .navbar { background: #ffffff; border-bottom-color: #e2e8f0; }
        body.light-mode .nav-brand { color: #3b82f6; }
        body.light-mode .nav-link { color: #64748b; }
        body.light-mode .nav-link:hover { background: #f1f5f9; color: #1e293b; }
        body.light-mode .nav-link.active { background: #3b82f6; color: #fff; }
        body.light-mode .project-banner { background: linear-gradient(135deg, #dbeafe 0%, #e0e7ff 100%); border-bottom-color: #e2e8f0; }
        body.light-mode .project-info-label { color: #64748b; }
        body.light-mode .project-info-value { color: #1e293b; }
        body.light-mode .project-info-value.highlight { color: #3b82f6; }
        body.light-mode .viewer-container { background: #e2e8f0; }
        body.light-mode .toolbar-group { background: rgba(255, 255, 255, 0.95); border-color: #cbd5e1; }
        body.light-mode .toolbar-group-label { color: #64748b; }
        body.light-mode .toolbar-btn { color: #475569; }
        body.light-mode .toolbar-btn:hover { background: #f1f5f9; color: #1e293b; }
        body.light-mode .toolbar-btn.active { background: #3b82f6; color: #fff; }
        body.light-mode .view-presets { background: rgba(255, 255, 255, 0.95); border-color: #cbd5e1; }
        body.light-mode .model-stats { background: rgba(255, 255, 255, 0.95); border-color: #cbd5e1; color: #64748b; }
        body.light-mode .stat-value { color: #1e293b; }
        body.light-mode .camera-info { background: rgba(255, 255, 255, 0.95); border-color: #cbd5e1; color: #64748b; }
        body.light-mode .sidebar { background: #ffffff; border-left-color: #e2e8f0; }
        body.light-mode .sidebar-header { border-bottom-color: #e2e8f0; }
        body.light-mode .search-box input { background: #f8fafc; border-color: #e2e8f0; color: #1e293b; }
        body.light-mode .search-box input::placeholder { color: #94a3b8; }
        body.light-mode .search-box i { color: #94a3b8; }
        body.light-mode .filter-select { background: #f8fafc; border-color: #e2e8f0; color: #1e293b; }
        body.light-mode .defect-list::-webkit-scrollbar-track { background: #f8fafc; }
        body.light-mode .defect-list::-webkit-scrollbar-thumb { background: #cbd5e1; }
        body.light-mode .defect-card { background: #f8fafc; border-color: #e2e8f0; }
        body.light-mode .defect-card:hover { border-color: #cbd5e1; }
        body.light-mode .defect-card.expanded, body.light-mode .defect-card.selected { background: #dbeafe; border-color: #3b82f6; }
        body.light-mode .defect-title { color: #1e293b; }
        body.light-mode .defect-description { color: #64748b; }
        body.light-mode .defect-coords { color: #94a3b8; }
        body.light-mode .defect-expanded { border-top-color: #e2e8f0; }
        body.light-mode .defect-meta-label { color: #94a3b8; }
        body.light-mode .defect-meta-value { color: #1e293b; }
        body.light-mode .defect-notes { background: #f1f5f9; color: #64748b; }
        body.light-mode .sidebar-footer { background: #f8fafc; border-top-color: #e2e8f0; }
        body.light-mode .empty-state { color: #94a3b8; }
        body.light-mode .empty-state h3 { color: #64748b; }
        body.light-mode .btn-outline { border-color: #cbd5e1; color: #64748b; }
        body.light-mode .btn-outline:hover { background: #f1f5f9; color: #1e293b; }
        body.light-mode .btn-secondary { background: #e2e8f0; color: #1e293b; }
        body.light-mode .btn-secondary:hover { background: #cbd5e1; }
        
        /* Navigation Bar */
        .navbar { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: #0f172a; border-bottom: 1px solid #1e293b; transition: all 0.3s; flex-shrink: 0; }
        .nav-left { display: flex; align-items: center; gap: 20px; }
        .nav-brand { display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 16px; color: #60a5fa; text-decoration: none; }
        .nav-brand i { font-size: 20px; }
        .nav-links { display: flex; gap: 8px; }
        .nav-link { padding: 8px 14px; border-radius: 6px; color: #94a3b8; text-decoration: none; font-size: 13px; font-weight: 500; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .nav-link:hover { background: #334155; color: #fff; }
        .nav-link.active { background: #3b82f6; color: #fff; }
        .nav-right { display: flex; align-items: center; gap: 12px; }
        
        /* Project Info Banner */
        .project-banner { background: #0f172a; border:1px solid #1e293b; padding: 12px 16px; border-radius: 0; margin: 0; flex-shrink: 0; }
        .project-info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; }
        .project-info-item { display: flex; flex-direction: column; gap: 4px; }
        .project-info-label { font-size: 11px; text-transform: uppercase; color: #64748b; font-weight: 600; letter-spacing: 0.5px; }
        .project-info-value { font-size: 14px; color: #cbd5e1; font-weight: 500; }
        .project-info-value.highlight { color: #60a5fa; font-size: 16px; }
        
        /* Buttons */
        .btn { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px; }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; }
        .btn-secondary { background: #374151; color: white; }
        .btn-secondary:hover { background: #4b5563; }
        .btn-outline { background: transparent; border: 1px solid #475569; color: #94a3b8; }
        .btn-outline:hover { background: #334155; color: #fff; border-color: #64748b; }
        .btn-icon { padding: 8px 10px; min-width: 36px; justify-content: center; }
        .btn-success { background: #22c55e; color: white; }
        .btn-success:hover { background: #16a34a; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        
        /* Main Layout - Full Page */
        .main-container { display: flex; flex: 1; height: 100%; overflow: hidden; }
        
        /* 3D Viewer */
        .viewer-container { flex: 1; position: relative; background: #0a0f1a; }
        #renderCanvas { width: 100%; height: 100%; display: block; }
        
        /* Viewer Toolbar */
        .viewer-toolbar { position: absolute; top: 16px; left: 16px; display: flex; flex-direction: column; gap: 8px; }
        .toolbar-group { display: flex; flex-direction: column; gap: 4px; background: rgba(30, 41, 59, 0.95); border-radius: 8px; padding: 6px; border: 1px solid #334155; }
        .toolbar-group-label { font-size: 9px; text-transform: uppercase; color: #64748b; padding: 4px 8px; font-weight: 600; }
        .toolbar-btn { padding: 10px 12px; background: transparent; border: none; color: #94a3b8; cursor: pointer; border-radius: 4px; transition: all 0.2s; font-size: 14px; }
        .toolbar-btn:hover { background: #334155; color: #fff; }
        .toolbar-btn.active { background: #3b82f6; color: #fff; }
        
        /* View Presets */
        .view-presets { position: absolute; top: 16px; right: 340px; display: flex; gap: 6px; background: rgba(30, 41, 59, 0.95); border-radius: 8px; padding: 6px; border: 1px solid #334155; }
        
        /* Model Stats */
        .model-stats { position: absolute; bottom: 16px; left: 16px; background: rgba(30, 41, 59, 0.95); padding: 12px 16px; border-radius: 8px; font-size: 12px; color: #94a3b8; border: 1px solid #334155; }
        .model-stats-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 4px; }
        .model-stats-row:last-child { margin-bottom: 0; }
        .stat-label { color: #64748b; }
        .stat-value { color: #e2e8f0; font-weight: 500; }
        
        /* Camera Info */
        .camera-info { position: absolute; bottom: 16px; right: 340px; background: rgba(30, 41, 59, 0.95); padding: 10px 14px; border-radius: 8px; font-size: 11px; color: #94a3b8; border: 1px solid #334155; }
        
        /* Sidebar */
        .sidebar { width: 320px; background: #1e293b; border-left: 1px solid #334155; display: flex; flex-direction: column; position: relative; z-index: 100; height: 100%; overflow: hidden; }
        .sidebar-header { padding: 16px; border-bottom: 1px solid #334155; }
        .sidebar-title { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .sidebar-title h2 { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .defect-count { background: #3b82f6; color: white; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: 600; }
        
        /* Search */
        .search-box { position: relative; margin-bottom: 12px; }
        .search-box input { width: 100%; padding: 10px 12px 10px 36px; background: #0f172a; border: 1px solid #334155; border-radius: 6px; color: #e5e7eb; font-size: 13px; }
        .search-box input:focus { outline: none; border-color: #3b82f6; }
        .search-box input::placeholder { color: #64748b; }
        .search-box i { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #64748b; font-size: 14px; }
        
        /* Filters */
        .filters { display: flex; gap: 8px; }
        .filter-select { flex: 1; padding: 8px 12px; background: #0f172a; border: 1px solid #334155; border-radius: 6px; color: #e5e7eb; font-size: 12px; }
        .filter-select:focus { outline: none; border-color: #3b82f6; }
        
        /* Defect List */
        .defect-list { flex: 1; overflow-y: auto; padding: 8px; }
        .defect-list::-webkit-scrollbar { width: 6px; }
        .defect-list::-webkit-scrollbar-track { background: #0f172a; }
        .defect-list::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        .defect-list::-webkit-scrollbar-thumb:hover { background: #475569; }
        
        .defect-card { background: #0f172a; border-radius: 8px; padding: 14px; margin-bottom: 8px; border: 1px solid #334155; transition: all 0.2s; cursor: pointer; }
        .defect-card:hover { border-color: #475569; transform: translateX(2px); }
        .defect-card.selected { border-color: #3b82f6; background: #1e3a5f; }
        .defect-card.expanded { border-color: #3b82f6; background: #1e3a5f; }
        
        .defect-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
        .defect-title { font-weight: 600; font-size: 14px; display: flex; align-items: center; gap: 6px; }
        .defect-index { color: #64748b; font-size: 12px; font-weight: normal; }
        .status-badge { padding: 4px 10px; border-radius: 4px; font-size: 10px; font-weight: 600; text-transform: uppercase; }
        .status-reported { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .status-review { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .status-fixed { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        
        .defect-description { font-size: 12px; color: #94a3b8; margin-bottom: 8px; line-height: 1.4; }
        .defect-coords { font-size: 11px; color: #64748b; display: flex; gap: 12px; }
        .coord-item { display: flex; align-items: center; gap: 4px; }
        .coord-label { color: #475569; }
        
        .defect-actions { display: flex; gap: 6px; justify-content: flex-end; margin-top: 12px; }
        .btn-small { padding: 6px 10px; font-size: 11px; border-radius: 4px; }
        
        /* Expandable defect details */
        .defect-expanded { display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid #334155; }
        .defect-card.expanded .defect-expanded { display: block; }
        .defect-thumbnail { width: 100%; max-height: 150px; object-fit: cover; border-radius: 6px; margin-bottom: 10px; cursor: pointer; transition: opacity 0.2s; }
        .defect-thumbnail:hover { opacity: 0.8; }
        .defect-meta-label { font-size: 10px; color: #64748b; margin-bottom: 4px; text-transform: uppercase; font-weight: 600; }
        .defect-meta-value { font-size: 13px; color: #e5e7eb; margin-bottom: 10px; word-break: break-word; }
        .defect-notes { font-size: 12px; color: #94a3b8; font-style: italic; background: #0f172a; padding: 8px; border-radius: 4px; }
        .no-image { color: #64748b; font-size: 12px; font-style: italic; }
        
        /* Sidebar Footer */
        .sidebar-footer { padding: 12px 16px; border-top: 1px solid #334155; background: #0f172a; }
        
        /* Modal - light/card style to match upload/process pages */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.35); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(4px); }
        .modal-overlay.active { display: flex; }
        .modal { background: #ffffff; border-radius: 12px; width: 520px; max-height: 80vh; overflow-y: auto; border: 1px solid #e2e8f0; box-shadow: 0 10px 30px rgba(15,23,42,0.08); }
        .modal-header { padding: 16px 20px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; }
        .modal-header h3 { font-size: 16px; display: flex; align-items: center; gap: 8px; color: #1e293b; }
        .modal-close { background: none; border: none; color: #64748b; font-size: 20px; cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: all 0.15s; }
        .modal-close:hover { background: #f1f5f9; color: #1e293b; }
        .modal-body { padding: 18px 20px; }
        .form-group { margin-bottom: 14px; }
        .form-group label { display: block; font-size: 12px; color: #64748b; margin-bottom: 6px; text-transform: uppercase; font-weight: 600; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px 12px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; color: #1e293b; font-size: 14px; }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.06); }
        .form-group textarea { min-height: 100px; resize: vertical; }
        .modal-footer { padding: 12px 20px; border-top: 1px solid #e2e8f0; display: flex; justify-content: flex-end; gap: 10px; }
        
        .defect-image { width: 100%; max-height: 220px; object-fit: cover; border-radius: 6px; margin-bottom: 12px; border: 1px solid #e5e7eb; }
        
        /* Empty State */
        .empty-state { text-align: center; padding: 40px 20px; color: #64748b; }
        .empty-state i { font-size: 48px; margin-bottom: 16px; opacity: 0.5; }
        .form-group input:readonly, .form-group textarea:readonly { background: #f1f5f9; color: #64748b; cursor: default; }
        
        .empty-state h3 { font-size: 16px; color: #94a3b8; margin-bottom: 8px; }
        .empty-state p { font-size: 13px; }
        
        /* Loading */
        .loading { display: flex; align-items: center; justify-content: center; height: 100%; color: #64748b; }
        .loading-spinner { width: 40px; height: 40px; border: 3px solid #334155; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <main class="card">
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-left">
            <a href="/projects" class="nav-brand">
                <i class="fas fa-cube"></i>
                LIDAR Defect Viewer
            </a>
            <div class="nav-links">
                <a href="/projects" class="nav-link"><i class="fas fa-folder-open"></i> Projects</a>
                <a href="/scans/{{ scan_id }}/visualize" class="nav-link active"><i class="fas fa-eye"></i> Visualize</a>
            </div>
        </div>
        <div class="nav-right">
            <button class="btn btn-outline btn-icon" id="themeToggle" onclick="toggleTheme()" title="Toggle Light/Dark Mode">
                <i class="fas fa-moon" id="themeIcon"></i>
            </button>
            <button class="btn btn-outline btn-icon" onclick="toggleDebugInspector()" title="Debug Inspector">
                <i class="fas fa-bug"></i>
            </button>
        </div>
    </nav>
    
    <!-- Project Info Banner -->
    <div class="project-banner">
        <div class="project-info-grid">
            <div class="project-info-item">
                <span class="project-info-label">Project Name</span>
                <span class="project-info-value highlight">{{ upload_metadata.project_name if upload_metadata and upload_metadata.project_name else scan.name or 'Untitled Project' }}</span>
            </div>
            <div class="project-info-item">
                <span class="project-info-label">Scan ID</span>
                <span class="project-info-value">#{{ scan.id }} - {{ scan.name }}</span>
            </div>
            <div class="project-info-item">
                <span class="project-info-label">Address</span>
                <span class="project-info-value">{{ upload_metadata.address if upload_metadata and upload_metadata.address else 'Not specified' }}</span>
            </div>
            <div class="project-info-item">
                <span class="project-info-label">Unit No.</span>
                <span class="project-info-value">{{ upload_metadata.unit_no if upload_metadata and upload_metadata.unit_no else 'N/A' }}</span>
            </div>
            <div class="project-info-item">
                <span class="project-info-label">Scan Date</span>
                <span class="project-info-value">{{ upload_metadata.scan_date if upload_metadata and upload_metadata.scan_date else (scan.created_at.strftime('%Y-%m-%d') if scan.created_at else 'Unknown') }}</span>
            </div>
            <div class="project-info-item">
                <span class="project-info-label">Model File</span>
                <span class="project-info-value">{{ scan.model_path.split('/')[-1] if scan.model_path else 'No model' }}</span>
            </div>
        </div>
    </div>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- 3D Viewer -->
        <div class="viewer-container">
            <canvas id="renderCanvas"></canvas>
            
            <!-- Left Toolbar (Camera Controls) -->
            <div class="viewer-toolbar">
                <div class="toolbar-group">
                    <span class="toolbar-group-label">Zoom</span>
                    <button class="toolbar-btn" onclick="zoomIn()" title="Zoom In"><i class="fas fa-search-plus"></i></button>
                    <button class="toolbar-btn" onclick="zoomOut()" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
                    <button class="toolbar-btn" onclick="fitToView()" title="Fit to View"><i class="fas fa-expand"></i></button>
                </div>
                <div class="toolbar-group">
                    <span class="toolbar-group-label">Display</span>
                    <button class="toolbar-btn" id="toggleDefectsBtn" onclick="toggleDefects()" title="Toggle Defects"><i class="fas fa-map-marker-alt"></i></button>
                    <button class="toolbar-btn" id="xrayBtn" onclick="toggleXRay()" title="X-Ray Mode"><i class="fas fa-x-ray"></i></button>
                    <button class="toolbar-btn" id="wireframeBtn" onclick="toggleWireframe()" title="Wireframe"><i class="fas fa-border-all"></i></button>
                </div>
            </div>
            
            <!-- View Presets -->
            <div class="view-presets">
                <button class="toolbar-btn" onclick="resetView()" title="Reset View"><i class="fas fa-sync"></i></button>
                <button class="toolbar-btn" onclick="setTopView()" title="Top View"><i class="fas fa-arrow-down"></i></button>
                <button class="toolbar-btn" onclick="setFrontView()" title="Front View"><i class="fas fa-arrow-right"></i></button>
                <button class="toolbar-btn" onclick="set3DView()" title="3D View"><i class="fas fa-cube"></i></button>
            </div>
            
            <!-- Model Stats -->
            <div class="model-stats" id="modelStats">
                <div class="model-stats-row">
                    <span class="stat-label">Meshes:</span>
                    <span class="stat-value" id="meshCount">0</span>
                </div>
                <div class="model-stats-row">
                    <span class="stat-label">Defects:</span>
                    <span class="stat-value" id="defectStat">0</span>
                </div>
                <div class="model-stats-row">
                    <span class="stat-label">Model Size:</span>
                    <span class="stat-value" id="modelSize">-</span>
                </div>
            </div>
            
            <!-- Camera Info -->
            <div class="camera-info" id="cameraInfo">
                <i class="fas fa-video"></i> Camera: X:0.0 Y:0.0 Z:0.0
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">
                    <h2><i class="fas fa-exclamation-triangle"></i> Defects</h2>
                    <span class="defect-count" id="defectCount">0</span>
                </div>
                
                <!-- Search -->
                <div class="search-box">
                    <i class="fas fa-search"></i>
                    <input type="text" id="defectSearch" placeholder="Search defects..." oninput="searchDefects()">
                </div>
                
                <!-- Filters -->
                <div class="filters">
                    <select class="filter-select" id="statusFilter" onchange="filterDefects()">
                        <option value="">All Status</option>
                        <option value="Reported">Reported</option>
                        <option value="Under Review">Under Review</option>
                        <option value="Fixed">Fixed</option>
                    </select>
                    <select class="filter-select" id="sortFilter" onchange="sortDefects()">
                        <option value="newest">Newest First</option>
                        <option value="oldest">Oldest First</option>
                        <option value="status">By Status</option>
                    </select>
                </div>
            </div>
            
            <!-- Defect List -->
            <div class="defect-list" id="defectList">
                <div class="loading">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Defect Detail Modal -->
    <div class="modal-overlay" id="defectModal">
        <div class="modal">
            <div class="modal-header">
                <h3><i class="fas fa-edit"></i> Edit Defect</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <img id="defectImage" class="defect-image" src="" alt="Defect Image" style="display: none;">
                <div class="form-group">
                    <label>Element</label>
                    <input type="text" id="defectElement" readonly>
                </div>
                <div class="form-group">
                    <label>Location</label>
                    <select id="defectLocation">
                        <option value="">Not Specified</option>
                        <option value="Living Room">Living Room</option>
                        <option value="Kitchen">Kitchen</option>
                        <option value="Dining Room">Dining Room</option>
                        <option value="Master Bedroom">Master Bedroom</option>
                        <option value="Bedroom 1">Bedroom 1</option>
                        <option value="Bedroom 2">Bedroom 2</option>
                        <option value="Bedroom 3">Bedroom 3</option>
                        <option value="Bathroom">Bathroom</option>
                        <option value="Toilet">Toilet</option>
                        <option value="Master Bathroom">Master Bathroom</option>
                        <option value="Balcony">Balcony</option>
                        <option value="Corridor">Corridor</option>
                        <option value="Entrance">Entrance</option>
                        <option value="Laundry">Laundry</option>
                        <option value="Storage">Storage</option>
                        <option value="Utility">Utility</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="defectType">
                        <option value="Unknown">Unknown</option>
                        <option value="Crack">Crack</option>
                        <option value="Water Damage">Water Damage</option>
                        <option value="Structural">Structural</option>
                        <option value="Finish">Finish</option>
                        <option value="Electrical">Electrical</option>
                        <option value="Plumbing">Plumbing</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Severity</label>
                    <select id="defectSeverity">
                        <option value="Low">Low</option>
                        <option value="Medium">Medium</option>
                        <option value="High">High</option>
                        <option value="Critical">Critical</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="defectDesc" readonly></textarea>
                </div>
                <div class="form-group">
                    <label>Coordinates</label>
                    <input type="text" id="defectCoords" readonly>
                </div>
                <div class="form-group">
                    <label>Status</label>
                    <select id="defectStatus">
                        <option value="Reported">Reported</option>
                        <option value="Under Review">Under Review</option>
                        <option value="Fixed">Fixed</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Notes</label>
                    <textarea id="defectNotes" placeholder="Add notes..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveDefect()"><i class="fas fa-save"></i> Save Changes</button>
            </div>
        </div>
    </div>

    <script>
        // Babylon.js setup
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.04, 0.06, 0.10, 1);
        
        // Enable anti-aliasing for smoother rendering
        scene.getEngine().setHardwareScalingLevel(1 / window.devicePixelRatio);
        
        // ==================== PBR ENVIRONMENT SETUP ====================
        // Create default PBR environment with Image-Based Lighting (IBL)
        const hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
            "https://playground.babylonjs.com/textures/environment.env", 
            scene
        );
        scene.environmentTexture = hdrTexture;
        scene.environmentIntensity = 1.0;
        
        // Create skybox for reflections (optional)
        const skybox = scene.createDefaultSkybox(hdrTexture, true, 1000, 0.3);
        
        // ==================== PBR MATERIAL RECIPES ====================
        const PBR_RECIPES = {
            // Walls - Plaster/Drywall (matte finish)
            'wall': {
                baseColor: new BABYLON.Color3(0.92, 0.92, 0.88),
                metallic: 0.0,
                roughness: 0.95,
                textureNames: {
                    albedo: 'plaster_albedo.jpg',
                    normal: 'plaster_normal.jpg',
                    roughness: 'plaster_roughness.jpg'
                }
            },
            
            // Floors - Dark Wood
            'floor': {
                baseColor: new BABYLON.Color3(0.25, 0.18, 0.12),
                metallic: 0.0,
                roughness: 0.7,
                textureNames: {
                    albedo: 'wood_dark_albedo.jpg',
                    normal: 'wood_dark_normal.jpg',
                    roughness: 'wood_dark_roughness.jpg'
                }
            },
            
            // Ceilings - White painted surface
            'ceiling': {
                baseColor: new BABYLON.Color3(0.96, 0.96, 0.96),
                metallic: 0.0,
                roughness: 0.9,
                textureNames: {
                    albedo: 'paint_white_albedo.jpg',
                    normal: 'paint_white_normal.jpg'
                }
            },
            
            // Doors - Painted wood (satin finish)
            'door': {
                baseColor: new BABYLON.Color3(0.85, 0.82, 0.75),
                metallic: 0.0,
                roughness: 0.4,
                textureNames: {
                    albedo: 'door_painted_albedo.jpg',
                    normal: 'door_painted_normal.jpg',
                    roughness: 'door_painted_roughness.jpg'
                }
            },
            
            // Windows - Glass with slight tint
            'window': {
                baseColor: new BABYLON.Color3(0.7, 0.85, 0.9),
                metallic: 0.9,
                roughness: 0.05,
                alpha: 0.4,
                textureNames: {
                    albedo: 'glass_albedo.jpg'
                }
            },
            
            // Sink - Polished Steel
            'sink': {
                baseColor: new BABYLON.Color3(0.75, 0.75, 0.75),
                metallic: 1.0,
                roughness: 0.2,
                textureNames: {
                    albedo: 'metal_steel_albedo.jpg',
                    normal: 'metal_steel_normal.jpg',
                    metallic: 'metal_steel_metallic.jpg',
                    roughness: 'metal_steel_roughness.jpg'
                }
            },
            
            // Table - Matte Wood Finish
            'table': {
                baseColor: new BABYLON.Color3(0.55, 0.4, 0.28),
                metallic: 0.0,
                roughness: 0.65,
                textureNames: {
                    albedo: 'wood_table_albedo.jpg',
                    normal: 'wood_table_normal.jpg',
                    roughness: 'wood_table_roughness.jpg'
                }
            },
            
            // Furniture - Generic wood
            'furniture': {
                baseColor: new BABYLON.Color3(0.5, 0.35, 0.25),
                metallic: 0.0,
                roughness: 0.6,
                textureNames: {
                    albedo: 'wood_furniture_albedo.jpg',
                    normal: 'wood_furniture_normal.jpg'
                }
            },
            
            // Roof - Dark tiles
            'roof': {
                baseColor: new BABYLON.Color3(0.2, 0.2, 0.22),
                metallic: 0.0,
                roughness: 0.8,
                textureNames: {
                    albedo: 'roof_tile_albedo.jpg',
                    normal: 'roof_tile_normal.jpg',
                    roughness: 'roof_tile_roughness.jpg'
                }
            },
            
            // Default - Generic surface
            'default': {
                baseColor: new BABYLON.Color3(0.7, 0.7, 0.7),
                metallic: 0.0,
                roughness: 0.75,
                textureNames: {}
            }
        };
        
        // ==================== PBR MATERIAL APPLICATION ====================
        function applyPBRMaterials(scene) {
            console.log('Applying PBR materials to scene...');
            let materialsApplied = 0;
            
            scene.meshes.forEach(mesh => {
                if (!mesh || mesh.name === '__root__' || mesh.name.toLowerCase().includes('snapshot')) {
                    return;
                }
                
                // Determine material type based on mesh name
                const meshName = mesh.name.toLowerCase();
                let recipeKey = 'default';
                
                // Match mesh name to PBR recipe
                if (meshName.includes('wall') || meshName.includes('vegg') || meshName.includes('ifcwall')) {
                    recipeKey = 'wall';
                } else if (meshName.includes('floor') || meshName.includes('gulv') || meshName.includes('slab')) {
                    recipeKey = 'floor';
                } else if (meshName.includes('ceiling') || meshName.includes('tak')) {
                    recipeKey = 'ceiling';
                } else if (meshName.includes('door') || meshName.includes('d√∏r')) {
                    recipeKey = 'door';
                } else if (meshName.includes('window') || meshName.includes('vindu')) {
                    recipeKey = 'window';
                } else if (meshName.includes('sink') || meshName.includes('vask')) {
                    recipeKey = 'sink';
                } else if (meshName.includes('table') || meshName.includes('bord')) {
                    recipeKey = 'table';
                } else if (meshName.includes('furniture') || meshName.includes('m√∏bel') || meshName.includes('furnishing')) {
                    recipeKey = 'furniture';
                } else if (meshName.includes('roof') || meshName.includes('tak')) {
                    recipeKey = 'roof';
                }
                
                const recipe = PBR_RECIPES[recipeKey];
                
                // Create PBR material
                const pbrMaterial = new BABYLON.PBRMetallicRoughnessMaterial(
                    `pbr_${mesh.name}`, 
                    scene
                );
                
                // Apply base properties
                pbrMaterial.baseColor = recipe.baseColor;
                pbrMaterial.metallic = recipe.metallic;
                pbrMaterial.roughness = recipe.roughness;
                
                // Handle transparency for glass
                if (recipe.alpha !== undefined) {
                    pbrMaterial.alpha = recipe.alpha;
                    pbrMaterial.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHABLEND;
                }
                
                // Enable environment reflections
                pbrMaterial.useRadianceOverAlpha = true;
                pbrMaterial.useSpecularOverAlpha = true;
                
                // Backface culling for proper 3D rendering
                pbrMaterial.backFaceCulling = true;
                pbrMaterial.twoSidedLighting = false;
                
                // Store original alpha for X-ray mode
                pbrMaterial.originalAlpha = pbrMaterial.alpha || 1.0;
                
                // TODO: Load textures if available
                // Example for future texture loading:
                // if (recipe.textureNames.albedo) {
                //     pbrMaterial.baseTexture = new BABYLON.Texture(
                //         `/static/textures/${recipe.textureNames.albedo}`, 
                //         scene
                //     );
                // }
                
                // Apply material to mesh
                mesh.material = pbrMaterial;
                materialsApplied++;
                
                console.log(`Applied ${recipeKey} PBR material to: ${mesh.name}`);
            });
            
            console.log(`‚úì Applied ${materialsApplied} PBR materials`);
            return materialsApplied;
        }
        
        // Camera
        const camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 2, Math.PI / 2.5, 20, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.wheelPrecision = 50;
        camera.minZ = 0.1;
        camera.maxZ = 1000;
        camera.panningSensibility = 100;
        camera.lowerRadiusLimit = 0.5;
        camera.upperRadiusLimit = 500;
        
        // Lighting for PBR - softer with environment contribution
        // Main ambient light (reduced since IBL provides base lighting)
        const light1 = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
        light1.intensity = 0.3; // Reduced from 0.6 for PBR
        light1.groundColor = new BABYLON.Color3(0.1, 0.1, 0.15);
        
        // Key directional light (sun simulation)
        const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(-1, -2, -1), scene);
        light2.intensity = 0.5; // Reduced from 0.8 for PBR
        
        // Fill light from opposite side
        const light3 = new BABYLON.DirectionalLight('light3', new BABYLON.Vector3(1, 0.5, 1), scene);
        light3.intensity = 0.2; // Reduced from 0.4 for PBR
        
        // State
        let defectsData = [];
        let filteredDefects = [];
        let markers = [];
        let currentDefectId = null;
        let defectsVisible = true;
        let xrayMode = false;
        let wireframeMode = false;
        let loadedMeshes = [];
        let modelCenter = BABYLON.Vector3.Zero();
        let modelLoaded = false;
        let modelBounds = { min: null, max: null, size: null };
        
        // Load 3D model
        let rootMesh = null;
        let snapshotMeshes = [];
        {% if model_url %}
        console.log('Loading model from: {{ model_url }}');
        BABYLON.SceneLoader.ImportMeshAsync('', '{{ model_url }}', '', scene, null, '.glb')
            .then(function(result) {
                console.log('Model loaded successfully, meshes:', result.meshes.length);
                loadedMeshes = result.meshes;
                modelLoaded = true;
                
                // Update mesh count
                document.getElementById('meshCount').textContent = result.meshes.length;
                
                // Find Snapshot meshes
                result.meshes.forEach(mesh => {
                    if (mesh.name === '__root__') {
                        rootMesh = mesh;
                    }
                    
                    if (mesh.name && mesh.name.toLowerCase().includes('snapshot')) {
                        mesh.computeWorldMatrix(true);
                        snapshotMeshes.push({
                            mesh: mesh,
                            name: mesh.name,
                            position: mesh.absolutePosition.clone()
                        });
                        mesh.isVisible = false;
                        console.log('Found Snapshot mesh:', mesh.name, 'at', mesh.absolutePosition.x.toFixed(2), mesh.absolutePosition.y.toFixed(2), mesh.absolutePosition.z.toFixed(2));
                    }
                });
                
                // Apply PBR materials to all meshes
                applyPBRMaterials(scene);
                
                console.log('Total Snapshot meshes found:', snapshotMeshes.length);
                
                // Center camera on model
                if (result.meshes.length > 0) {
                    let min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                    let max = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    result.meshes.forEach(mesh => {
                        if (mesh.getBoundingInfo && mesh.name !== '__root__' && !mesh.name.toLowerCase().includes('snapshot')) {
                            mesh.computeWorldMatrix(true);
                            const boundingInfo = mesh.getBoundingInfo();
                            min = BABYLON.Vector3.Minimize(min, boundingInfo.boundingBox.minimumWorld);
                            max = BABYLON.Vector3.Maximize(max, boundingInfo.boundingBox.maximumWorld);
                        }
                    });
                    modelCenter = min.add(max).scale(0.5);
                    const size = max.subtract(min);
                    modelBounds = { min, max, size };
                    
                    // Update model size display
                    document.getElementById('modelSize').textContent = 
                        `${size.x.toFixed(1)} x ${size.y.toFixed(1)} x ${size.z.toFixed(1)}`;
                    
                    camera.target = modelCenter;
                    camera.radius = size.length() * 1.5;
                    console.log('Camera centered at:', modelCenter, 'radius:', camera.radius);
                    
                    createMarkersFromSnapshots();
                    loadDefects();
                }
            })
            .catch(function(error) {
                console.error('Error loading model:', error);
                loadDefects();
            });
        {% else %}
        console.log('No model URL provided');
        loadDefects();
        {% endif %}
        
        // Fetch and render defects
        function loadDefects() {
            fetch('/scans/{{ scan_id }}/defects')
                .then(response => response.json())
                .then(defects => {
                    defectsData = defects;
                    filteredDefects = [...defects];
                    renderDefectList(filteredDefects);
                    renderDefectMarkers(defects);
                    document.getElementById('defectCount').textContent = defects.length;
                    document.getElementById('defectStat').textContent = defects.length;
                });
        }
        
        function renderDefectList(defects) {
            const listEl = document.getElementById('defectList');
            
            if (defects.length === 0) {
                listEl.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-check-circle"></i>
                        <h3>No Defects Found</h3>
                        <p>No defects match your current filters</p>
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = defects.map((d, index) => `
                <div class="defect-card" data-id="${d.defectId}" id="card-${d.defectId}" onclick="toggleDefectCard(${d.defectId})">
                    <div class="defect-header">
                        <span class="defect-title">
                            <i class="fas fa-exclamation-circle" style="color: ${getSeverityColorHex(d.severity)};"></i>
                            Defect <span class="defect-index">#${d.defectId}</span>
                        </span>
                        <span class="status-badge ${getStatusClass(d.status)}">${d.status}</span>
                    </div>
                    <div class="defect-description"><strong>${d.location ? 'üìç ' + d.location : 'No location'}</strong> - ${d.element || 'Unknown Element'}</div>
                    <div class="defect-description">${d.defect_type || 'Unknown'}</div>
                    <div class="defect-coords">
                        <span class="coord-item"><span class="coord-label">X:</span> ${d.x.toFixed(2)}</span>
                        <span class="coord-item"><span class="coord-label">Y:</span> ${d.y.toFixed(2)}</span>
                        <span class="coord-item"><span class="coord-label">Z:</span> ${d.z.toFixed(2)}</span>
                    </div>
                    
                    <!-- Expanded content -->
                    <div class="defect-expanded" id="expanded-${d.defectId}">
                        <div class="defect-meta-label">Image</div>
                        <div id="defect-img-${d.defectId}" class="defect-meta-value">
                            <span class="no-image">Loading...</span>
                        </div>
                        
                        <div class="defect-meta-label">Location</div>
                        <div class="defect-meta-value">${d.location || 'Not specified'}</div>
                        
                        <div class="defect-meta-label">Element</div>
                        <div class="defect-meta-value">${d.element || 'Unknown'}</div>
                        
                        <div class="defect-meta-label">Type</div>
                        <div class="defect-meta-value">${d.defect_type || 'Unknown'}</div>
                        
                        <div class="defect-meta-label">Severity</div>
                        <div class="defect-meta-value" style="color: ${getSeverityColorHex(d.severity)};">${d.severity || 'Medium'}</div>
                        
                        <div class="defect-meta-label">Description</div>
                        <div class="defect-meta-value">${d.description || 'No description'}</div>
                        
                        <div class="defect-meta-label">Notes</div>
                        <div id="defect-notes-${d.defectId}" class="defect-notes">Loading...</div>
                        
                        <div class="defect-meta-label">Created</div>
                        <div class="defect-meta-value">${d.created_at || 'Unknown'}</div>
                        
                        <div class="defect-actions">
                            <button class="btn btn-small btn-outline" onclick="event.stopPropagation(); focusDefect(${d.defectId})">
                                <i class="fas fa-crosshairs"></i> Focus
                            </button>
                            <button class="btn btn-small btn-primary" onclick="event.stopPropagation(); openDefectModal(${d.defectId})">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                            <button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteDefect(${d.defectId})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function getStatusClass(status) {
            switch(status) {
                case 'Reported': return 'status-reported';
                case 'Under Review': return 'status-review';
                case 'Fixed': return 'status-fixed';
                default: return 'status-reported';
            }
        }
        
        function getStatusColorHex(status) {
            switch(status) {
                case 'Reported': return '#ef4444';
                case 'Under Review': return '#f59e0b';
                case 'Fixed': return '#22c55e';
                default: return '#6b7280';
            }
        }
        
        function getSeverityColorHex(severity) {
            switch(severity) {
                case 'Low': return '#22c55e';  // Green
                case 'Medium': return '#f59e0b';  // Yellow/Orange
                case 'High': return '#f97316';  // Orange
                case 'Critical': return '#ef4444';  // Red
                default: return '#f59e0b';  // Default to yellow
            }
        }
        
        function truncateText(text, maxLen) {
            if (!text) return '';
            return text.length > maxLen ? text.substring(0, maxLen) + '...' : text;
        }
        
        // Search functionality
        function searchDefects() {
            applyFilters();
        }
        
        // Filter functionality
        function filterDefects() {
            applyFilters();
        }
        
        // Sort functionality
        function sortDefects() {
            applyFilters();
        }
        
        function applyFilters() {
            const searchQuery = document.getElementById('defectSearch').value.toLowerCase();
            const statusFilter = document.getElementById('statusFilter').value;
            const sortBy = document.getElementById('sortFilter').value;
            
            filteredDefects = defectsData.filter(d => {
                const matchesSearch = !searchQuery || 
                    (d.description && d.description.toLowerCase().includes(searchQuery)) ||
                    d.defectId.toString().includes(searchQuery);
                const matchesStatus = !statusFilter || d.status === statusFilter;
                return matchesSearch && matchesStatus;
            });
            
            // Sort
            switch(sortBy) {
                case 'newest':
                    filteredDefects.sort((a, b) => b.defectId - a.defectId);
                    break;
                case 'oldest':
                    filteredDefects.sort((a, b) => a.defectId - b.defectId);
                    break;
                case 'status':
                    const statusOrder = { 'Reported': 0, 'Under Review': 1, 'Fixed': 2 };
                    filteredDefects.sort((a, b) => statusOrder[a.status] - statusOrder[b.status]);
                    break;
            }
            
            renderDefectList(filteredDefects);
        }
        
        function toggleDefectCard(defectId) {
            const card = document.getElementById('card-' + defectId);
            if (!card) return;
            
            const wasExpanded = card.classList.contains('expanded');
            
            // Collapse all cards first
            document.querySelectorAll('.defect-card').forEach(c => {
                c.classList.remove('expanded');
            });
            
            // Reset all markers to normal size
            markers.forEach(m => {
                m.scaling = new BABYLON.Vector3(1, 1, 1);
            });
            
            if (!wasExpanded) {
                card.classList.add('expanded');
                loadDefectDetails(defectId);
                
                // Highlight the marker
                const defectIndex = defectsData.findIndex(d => d.defectId === defectId);
                if (defectIndex >= 0 && defectIndex < markers.length) {
                    markers[defectIndex].scaling = new BABYLON.Vector3(1.5, 1.5, 1.5);
                }
            }
        }
        
        function loadDefectDetails(defectId) {
            fetch('/defect/' + defectId)
                .then(response => response.json())
                .then(data => {
                    // Update image
                    const imgContainer = document.getElementById('defect-img-' + defectId);
                    if (imgContainer) {
                        if (data.imageUrl) {
                            imgContainer.innerHTML = '<img src="' + data.imageUrl + '" class="defect-thumbnail" onclick="event.stopPropagation(); window.open(\'' + data.imageUrl + '\', \'_blank\')" alt="Defect Image">';
                        } else {
                            imgContainer.innerHTML = '<span class="no-image">No image attached</span>';
                        }
                    }
                    
                    // Update notes
                    const notesEl = document.getElementById('defect-notes-' + defectId);
                    if (notesEl) {
                        notesEl.textContent = data.notes || 'No notes added';
                    }
                })
                .catch(err => console.error('Error loading defect details:', err));
        }
        
        // Create markers from GLB Snapshot meshes
        function createMarkersFromSnapshots() {
            markers.forEach(m => m.dispose());
            markers = [];
            
            snapshotMeshes.forEach((snapshot, index) => {
                const marker = BABYLON.MeshBuilder.CreateSphere('marker_' + index, {diameter: 0.25}, scene);
                marker.position = snapshot.position.clone();
                
                const material = new BABYLON.StandardMaterial('markerMat_' + index, scene);
                material.diffuseColor = new BABYLON.Color3(0.86, 0.15, 0.15);
                material.emissiveColor = new BABYLON.Color3(0.86, 0.15, 0.15);
                material.disableLighting = true;
                marker.material = material;
                marker.snapshotName = snapshot.name;
                marker.snapshotIndex = index;
                
                markers.push(marker);
            });
            
            document.getElementById('defectCount').textContent = markers.length;
            document.getElementById('defectStat').textContent = markers.length;
        }
        
        function updateMarkerColors() {
            markers.forEach((marker, index) => {
                if (index < defectsData.length) {
                    const defect = defectsData[index];
                    marker.material.diffuseColor = getSeverityColor(defect.severity);
                    marker.material.emissiveColor = getSeverityColor(defect.severity);
                    marker.defectId = defect.defectId;
                    marker.severity = defect.severity;
                }
            });
        }
        
        function renderDefectMarkers(defects) {
            if (markers.length > 0) {
                updateMarkerColors();
                return;
            }
            
            // Fallback: create markers from database coordinates
            defects.forEach((defect) => {
                const marker = BABYLON.MeshBuilder.CreateSphere('marker' + defect.defectId, {diameter: 0.25}, scene);
                marker.position = new BABYLON.Vector3(defect.x, defect.y, defect.z);
                
                const material = new BABYLON.StandardMaterial('mat' + defect.defectId, scene);
                material.diffuseColor = getSeverityColor(defect.severity);
                material.emissiveColor = getSeverityColor(defect.severity);
                material.disableLighting = true;
                marker.material = material;
                marker.defectId = defect.defectId;
                marker.severity = defect.severity;
                
                markers.push(marker);
            });
        }
        
        function getStatusColor(status) {
            switch(status) {
                case 'Reported': return new BABYLON.Color3(0.86, 0.15, 0.15);
                case 'Under Review': return new BABYLON.Color3(0.96, 0.62, 0.04);
                case 'Fixed': return new BABYLON.Color3(0.13, 0.77, 0.35);
                default: return new BABYLON.Color3(0.5, 0.5, 0.5);
            }
        }
        
        function getSeverityColor(severity) {
            switch(severity) {
                case 'Low': return new BABYLON.Color3(0.13, 0.77, 0.35);  // Green
                case 'Medium': return new BABYLON.Color3(0.96, 0.62, 0.04);  // Yellow/Orange
                case 'High': return new BABYLON.Color3(0.98, 0.45, 0.09);  // Orange
                case 'Critical': return new BABYLON.Color3(0.94, 0.27, 0.27);  // Red
                default: return new BABYLON.Color3(0.96, 0.62, 0.04);  // Default to yellow
            }
        }
        
        // Click handler for markers
        scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                const pickResult = scene.pick(pointerInfo.event.clientX, pointerInfo.event.clientY);
                if (pickResult.hit && pickResult.pickedMesh.name.startsWith('marker')) {
                    const defectId = pickResult.pickedMesh.defectId;
                    const snapshotIndex = pickResult.pickedMesh.snapshotIndex;
                    if (defectId) {
                        openDefectModal(defectId);
                    } else if (snapshotIndex !== undefined && snapshotIndex < defectsData.length) {
                        openDefectModal(defectsData[snapshotIndex].defectId);
                    }
                }
            }
        });
        
        function selectDefect(defectId) {
            document.querySelectorAll('.defect-card').forEach(c => c.classList.remove('selected', 'expanded'));
            const card = document.querySelector(`.defect-card[data-id="${defectId}"]`);
            if (card) {
                card.classList.add('selected', 'expanded');
                loadDefectDetails(defectId);
                card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        function focusDefect(defectId) {
            const defectIndex = defectsData.findIndex(d => d.defectId === defectId);
            if (defectIndex >= 0 && defectIndex < markers.length) {
                const marker = markers[defectIndex];
                camera.target = marker.position.clone();
                camera.radius = 3;
            } else {
                const defect = defectsData.find(d => d.defectId === defectId);
                if (defect) {
                    camera.target = new BABYLON.Vector3(defect.x, defect.y, defect.z);
                    camera.radius = 3;
                }
            }
            selectDefect(defectId);
        }
        
        function openDefectModal(defectId) {
            currentDefectId = defectId;
            fetch(`/defect/${defectId}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('defectElement').value = data.element || 'Unknown';
                    document.getElementById('defectLocation').value = data.location || '';
                    document.getElementById('defectType').value = data.defect_type || 'Unknown';
                    document.getElementById('defectSeverity').value = data.severity || 'Medium';
                    document.getElementById('defectDesc').value = data.description || '';
                    document.getElementById('defectCoords').value = `X: ${data.x}, Y: ${data.y}, Z: ${data.z}`;
                    document.getElementById('defectStatus').value = data.status;
                    document.getElementById('defectNotes').value = data.notes || '';
                    if (data.imageUrl) {
                        document.getElementById('defectImage').src = data.imageUrl;
                        document.getElementById('defectImage').style.display = 'block';
                    } else {
                        document.getElementById('defectImage').style.display = 'none';
                    }
                    document.getElementById('defectModal').classList.add('active');
                });
        }
        
        function closeModal() {
            document.getElementById('defectModal').classList.remove('active');
            currentDefectId = null;
        }
        
        function saveDefect() {
            const location = document.getElementById('defectLocation').value;
            const defect_type = document.getElementById('defectType').value;
            const severity = document.getElementById('defectSeverity').value;
            const status = document.getElementById('defectStatus').value;
            const notes = document.getElementById('defectNotes').value;
            fetch(`/defect/${currentDefectId}/status`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ location, defect_type, severity, status, notes })
            })
            .then(response => response.json())
            .then(() => {
                closeModal();
                loadDefects();
            });
        }
        
        function deleteDefect(defectId) {
            if (confirm('Are you sure you want to delete this defect?')) {
                fetch(`/defect/${defectId}`, { method: 'DELETE' })
                    .then(response => response.json())
                    .then(() => loadDefects());
            }
        }
        
        // View controls
        function resetView() {
            camera.alpha = -Math.PI / 2;
            camera.beta = Math.PI / 2.5;
            if (modelBounds.size) {
                camera.radius = modelBounds.size.length() * 1.5;
                camera.target = modelCenter;
            } else {
                camera.radius = 20;
                camera.target = BABYLON.Vector3.Zero();
            }
        }
        
        function setTopView() {
            camera.alpha = 0;
            camera.beta = 0.01;
            camera.target = modelCenter;
        }
        
        function setFrontView() {
            camera.alpha = -Math.PI / 2;
            camera.beta = Math.PI / 2;
            camera.target = modelCenter;
        }
        
        function set3DView() {
            camera.alpha = -Math.PI / 4;
            camera.beta = Math.PI / 3;
            camera.target = modelCenter;
        }
        
        function zoomIn() {
            camera.radius = Math.max(1, camera.radius * 0.8);
        }
        
        function zoomOut() {
            camera.radius = camera.radius * 1.25;
        }
        
        function fitToView() {
            if (modelBounds.size) {
                camera.target = modelCenter;
                camera.radius = modelBounds.size.length() * 1.2;
            }
        }
        
        function toggleDefects() {
            defectsVisible = !defectsVisible;
            markers.forEach(m => m.isVisible = defectsVisible);
            document.getElementById('toggleDefectsBtn').classList.toggle('active', defectsVisible);
        }
        
        function toggleXRay() {
            xrayMode = !xrayMode;
            loadedMeshes.forEach(mesh => {
                if (mesh.material && !mesh.name.startsWith('marker') && !mesh.name.toLowerCase().includes('snapshot')) {
                    if (xrayMode) {
                        // High transparency for X-ray mode (0.15 = 85% transparent)
                        mesh.material.alpha = 0.15;
                        // Disable backface culling to see through objects
                        mesh.material.backFaceCulling = false;
                    } else {
                        // Restore original alpha or default to 1
                        mesh.material.alpha = mesh.material.originalAlpha || 1.0;
                        // Re-enable backface culling
                        mesh.material.backFaceCulling = true;
                    }
                }
            });
            document.getElementById('xrayBtn').classList.toggle('active', xrayMode);
        }
        
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            loadedMeshes.forEach(mesh => {
                if (mesh.material && !mesh.name.startsWith('marker')) {
                    mesh.material.wireframe = wireframeMode;
                }
            });
            document.getElementById('wireframeBtn').classList.toggle('active', wireframeMode);
        }
        
        function toggleDebugInspector() {
            if (scene.debugLayer.isVisible()) {
                scene.debugLayer.hide();
            } else {
                scene.debugLayer.show();
            }
        }
        
        // Theme toggle
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            
            body.classList.toggle('light-mode');
            const isLight = body.classList.contains('light-mode');
            
            // Update icon
            if (isLight) {
                themeIcon.className = 'fas fa-sun';
                // Light mode 3D scene background
                scene.clearColor = new BABYLON.Color4(0.89, 0.91, 0.94, 1);
            } else {
                themeIcon.className = 'fas fa-moon';
                // Dark mode 3D scene background
                scene.clearColor = new BABYLON.Color4(0.04, 0.06, 0.10, 1);
            }
            
            // Save preference
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
        }
        
        // Load saved theme on page load
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.getElementById('themeIcon').className = 'fas fa-sun';
                if (typeof scene !== 'undefined') {
                    scene.clearColor = new BABYLON.Color4(0.89, 0.91, 0.94, 1);
                }
            }
        });
        
        // Update camera info
        scene.registerBeforeRender(() => {
            const pos = camera.position;
            document.getElementById('cameraInfo').innerHTML = 
                `<i class="fas fa-video"></i> X:${pos.x.toFixed(1)} Y:${pos.y.toFixed(1)} Z:${pos.z.toFixed(1)} | Zoom: ${camera.radius.toFixed(1)}`;
        });
        
        // Render loop
        engine.runRenderLoop(() => {
            scene.render();
        });
        
        window.addEventListener('resize', () => {
            engine.resize();
        });
        
        // Initial load - only if no model URL
        {% if not model_url %}
        loadDefects();
        {% endif %}
    </script>
    </main>
</body>
</html>
